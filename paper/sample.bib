% Encoding: UTF-8

@Misc{RUBY2020,
  title    = {{\textgreater}{Ruby} {Style} {Guide}},
  abstract = {Ruby style guide: This style guide recommends a standard practices so that in real-world we can write good code. The guide is separated into several sections.},
  journal  = {w3resource},
  url      = {https://www.w3resource.com/ruby-programming/ruby-classes.php#line-length},
  urldate  = {2020-04-10},
  year = {2020}

}

@Misc{PEP8,
  title    = {{PEP} 8 -- {Style} {Guide} for {Python} {Code}},
  abstract = {The official home of the Python Programming Language},
  journal  = {Python.org},
  language = {en},
  url      = {https://www.python.org/dev/peps/pep-0008/#maximum-line-length},
  urldate  = {2020-04-08},
  year = {2020}
}


@Misc{Male2020,
  author    = {Male, Antony},
  month     = apr,
  note      = {original-date: 2015-02-08T17:08:40Z},
  title     = {canton7/{SyncTrayzor}},
  year      = {2020},
  abstract  = {Windows tray utility / filesystem watcher / launcher for Syncthing},
  copyright = {MIT},
  url       = {https://github.com/canton7/SyncTrayzor},
  urldate   = {2020-04-03},
}

@inproceedings{Rahman2018a,
  author    = {Rahman, Akond and Williams, Laurie},
  title     = {Characterizing {Defective} {Configuration} {Scripts} {Used} for {Continuous} {Deployment}},
  booktitle = {2018 {IEEE} 11th {International} {Conference} on {Software} {Testing}, {Verification} and {Validation} ({ICST})},
  year      = {2018},
  pages     = {34--45},
  month     = apr,
  note      = {ISSN: null},
  abstract  = {In software engineering, validation and verification (V\&V) resources are limited and characterization of defective software source files can help in efficiently allocating V\&V resources. Similar to software source files, defects occur in the scripts used to automatically manage configurations and software deployment infrastructure, often known as infrastructure as code (IaC) scripts. Defects in IaC scripts can have dire consequences, for example, creating large-scale system outages. Identifying the characteristics of defective IaC scripts can help in mitigating these defects by allocating V\&V efforts efficiently based upon these characteristics. The objective of this paper is to help software practitioners to prioritize validation and verification efforts for infrastructure as code (IaC) scripts by identifying the characteristics of defective IaC scripts. Researchers have previously extracted text features to characterize defective software source files written in general purpose programming languages. We investigate if text features can be used to identify properties that characterize defective IaC scripts. We use two text mining techniques to extract text features from IaC scripts: the bag-of-words technique, and the term frequency-inverse document frequency (TF-IDF) technique. Using the extracted features and applying grounded theory, we characterize defective IaC scripts. We also use the text features to build defect prediction models with tuned statistical learners. We mine open source repositories from Mozilla, Openstack, and Wikimedia Commons, to construct three case studies and evaluate our methodology. We identify three properties that characterize defective IaC scripts: filesystem operations, infrastructure provisioning, and managing user accounts. Using the bag-of-word technique, we observe a median F-Measure of 0.74, 0.71, and 0.73, respectively, for Mozilla, Openstack, and Wikimedia Commons. Using the TF-IDF technique, we observe a median F-Measure of 0.72, 0.74, and 0.70, respectively, for Mozilla, Openstack, and Wikimedia Commons.},
  doi       = {10.1109/ICST.2018.00014},
  file      = {IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/abstract/document/8367034:text/html},
  issn      = {null},
  keywords  = {data mining, program verification, resource allocation, software engineering, software fault tolerance, text analysis, defective IaC scripts, defective software source files, code scripts, user account management, infrastructure provisioning, filesystem operations, term frequency-inverse document frequency, bag-of-words technique, text mining, V\&V resource allocation, validation and verification resources, defective configuration scripts, text feature extraction, Feature extraction, Software, Predictive models, Text mining, Organizations, Measurement, DSL, configuration as code, continuous deployment, defect, devops, infrastructure as code, puppet}
}

@article{Rahman2019,
  author   = {Rahman, Akond and Mahdavi-Hezaveh, Rezvan and Williams, Laurie},
  title    = {A systematic mapping study of infrastructure as code research},
  journal  = {Information and Software Technology},
  year     = {2019},
  volume   = {108},
  pages    = {65--77},
  month    = apr,
  issn     = {0950-5849},
  abstract = {Context: Infrastructure as code (IaC) is the practice to automatically configure system dependencies and to provision local and remote instances. Practitioners consider IaC as a fundamental pillar to implement DevOps practices, which helps them to rapidly deliver software and services to end-users. Information technology (IT) organizations, such as GitHub, Mozilla, Facebook, Google and Netflix have adopted IaC. A systematic mapping study on existing IaC research can help researchers to identify potential research areas related to IaC, for example defects and security flaws that may occur in IaC scripts. Objective: The objective of this paper is to help researchers identify research areas related to infrastructure as code (IaC) by conducting a systematic mapping study of IaC-related research. Method: We conduct our research study by searching five scholar databases. We collect a set of 31,498 publications by using seven search strings. By systematically applying inclusion and exclusion criteria, which includes removing duplicates and removing non-English and non peer-reviewed publications, we identify 32 publications related to IaC. We identify topics addressed in these publications by applying qualitative analysis. Results: We identify four topics studied in IaC-related publications: (i) framework/tool for infrastructure as code; (ii) adoption of infrastructure as code; (iii) empirical study related to infrastructure as code; and (iv) testing in infrastructure as code. According to our analysis, 50.0\% of the studied 32 publications propose a framework or tool to implement the practice of IaC or extend the functionality of an existing IaC tool. Conclusion: Our findings suggest that framework or tools is a well-studied topic in IaC research. As defects and security flaws can have serious consequences for the deployment and development environments in DevOps, we observe the need for research studies that will study defects and security flaws for IaC.},
  doi      = {10.1016/j.infsof.2018.12.004},
  file     = {ScienceDirect Snapshot:https\://www.sciencedirect.com/science/article/abs/pii/S0950584918302507:text/html},
  keywords = {Devops, Configuration as code, Configuration script, Continuous deployment, Infrastructure as code, Software engineering, Systematic mapping study},
  language = {en},
  url      = {http://www.sciencedirect.com/science/article/pii/S0950584918302507},
  urldate  = {2020-01-06TZ}
}

@inproceedings{Sharma2016,
  author    = {Sharma, Tushar and Fragkoulis, Marios and Spinellis, Diomidis},
  title     = {Does {Your} {Configuration} {Code} {Smell}?},
  booktitle = {2016 {IEEE}/{ACM} 13th {Working} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
  year      = {2016},
  pages     = {189--200},
  month     = may,
  note      = {ISSN: null},
  abstract  = {Infrastructure as Code (IaC) is the practice of specifying computing system configurations through code, and managing them through traditional software engineering methods. The wide adoption of configuration management and increasing size and complexity of the associated code, prompt for assessing, maintaining, and improving the configuration code's quality. In this context, traditional software engineering knowledge and best practices associated with code quality management can be leveraged to assess and manage configuration code quality. We propose a catalog of 13 implementation and 11 design configuration smells, where each smell violates recommended best practices for configuration code. We analyzed 4,621 Puppet repositories containing 8.9 million lines of code and detected the cataloged implementation and design configuration smells. Our analysis reveals that the design configuration smells show 9\% higher average co-occurrence among themselves than the implementation configuration smells. We also observed that configuration smells belonging to a smell category tend to co-occur with configuration smells belonging to another smell category when correlation is computed by volume of identified smells. Finally, design configuration smell density shows negative correlation whereas implementation configuration smell density exhibits no correlation with the size of a configuration management system.},
  file      = {IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/abstract/document/7832899:text/html},
  issn      = {null},
  keywords  = {software maintenance, software quality, configuration management system, smell category, puppet repositories, code quality management, software engineering knowledge, computing system configurations, IaC, infrastructure as code, configuration code, Best practices, Software, Software engineering, Correlation, Context, Production, Data mining, Infrastructure as Code, Code quality, Configuration smells, Technical debt, Maintainability}
}

@inproceedings{Copeland2010,
  author     = {Copeland, Patrick},
  title      = {Google's {Innovation} {Factory}: {Testing}, {Culture}, and {Infrastructure}},
  booktitle  = {Proceedings of the 2010 {Third} {International} {Conference} on {Software} {Testing}, {Verification} and {Validation}},
  year       = {2010},
  series     = {{ICST} '10},
  pages      = {11--14},
  address    = {Washington, DC, USA},
  publisher  = {IEEE Computer Society},
  abstract   = {Google’s external mythology has been one of a brilliant and chaotic innovation machine that produces new products and features at an amazing rate. Behind the curtain of public perception is a company that takes quality seriously and is reinventing how software is created, tested, released, and maintained; a reality that’s even more interesting than the myth. At Google we’ve learned a lot in the last few years about accelerating very large scale software development; in this paper we'll share what has worked and what hasn't worked for us.},
  doi        = {10.1109/ICST.2010.65},
  isbn       = {9780769539904},
  keywords   = {Google, Testing, Process},
  shorttitle = {Google's {Innovation} {Factory}},
  url        = {http://dx.doi.org/10.1109/ICST.2010.65},
  urldate    = {2019-10-15TZ}
}

@misc{,
  title    = {({PDF}) {Continuous} {Integration} and {Continuous} {Delivery} {Pipeline} {Automation} for {Agile} {Software} {Project} {Management}},
  abstract = {ResearchGate is a network dedicated to science and research. Connect, collaborate and discover scientific publications, jobs and conferences. All for free.},
  file     = {Snapshot:https\://www.researchgate.net/publication/326406017_Continuous_Integration_and_Continuous_Delivery_Pipeline_Automation_for_Agile_Software_Project_Management:text/html},
  journal  = {ResearchGate},
  language = {en},
  url      = {https://www.researchgate.net/publication/326406017_Continuous_Integration_and_Continuous_Delivery_Pipeline_Automation_for_Agile_Software_Project_Management},
  urldate  = {CURRENT\_TIMESTAMP}
}

@misc{,
  title    = {Continuous {Deployment} of {Mobile} {Software} at {Facebook} ({Showcase})},
  abstract = {This paper describes in detail the software update mobile deployment process at Facebook.},
  chapter  = {Systems \& Networking},
  file     = {Snapshot:https\://research.fb.com/publications/continuous-deployment-of-mobile-software-at-facebook-showcase/:text/html},
  journal  = {Facebook Research},
  language = {en-US},
  url      = {https://research.fb.com/publications/continuous-deployment-of-mobile-software-at-facebook-showcase/},
  urldate  = {CURRENT\_TIMESTAMP}
}

@inproceedings{Munoz2018,
  author    = {Muñoz, César A. and Narkawicz, Anthony and Dutle, Aaron},
  title     = {From {Formal} {Requirements} to {Highly} {Assured} {Software} for {Unmanned} {Aircraft} {Systems}},
  booktitle = {{FM}},
  year      = {2018},
  abstract  = {Operational requirements of safety-critical systems are often written in restricted specification logics. These restricted logics are amenable to automated analysis techniques such as model-checking, but are not rich enough to express complex requirements of unmanned systems. This short paper advocates for the use of expressive logics, such as higher-order logic, to specify the complex operational requirements and safety properties of unmanned systems. These rich logics are less amenable to automation and, hence, require the use of interactive theorem proving techniques. However, these logics support the formal verification of complex requirements such as those involving the physical environment. Moreover, these logics enable validation techniques that increase confidence in the correctness of numerically intensive software. These features result in highly-assured software that may be easier to certify. The feasibility of this approach is illustrated with examples drawn for NASA’s unmanned aircraft systems.},
  doi       = {10.1007/978-3-319-95582-7_38},
  file      = {Semantic Scholar Link:https\://www.semanticscholar.org/paper/From-Formal-Requirements-to-Highly-Assured-Software-Mu%C3%B1oz-Narkawicz/1143a4c041e6c08b04dad117c8101e1d28a996f6:text/html},
  keywords  = {Requirement, Unmanned aerial vehicle, Formal verification, Model checking, Robotics, Proof assistant, Automated theorem proving, Correctness (computer science), Numerical analysis, Specification language}
}

@article{Meyer2014,
  author   = {Meyer, M.},
  title    = {Continuous {Integration} and {Its} {Tools}},
  journal  = {IEEE Software},
  year     = {2014},
  volume   = {31},
  number   = {3},
  pages    = {14--16},
  month    = may,
  abstract = {Continuous integration has been around for a while now, but the habits it suggests are far from common practice. Automated builds, a thorough test suite, and committing to the mainline branch every day sound simple at first, but they require a responsible team to implement and constant care. What starts with improved tooling can be a catalyst for long-lasting change in your company's shipping culture. Continuous integration is more than a set of practices, it's a mindset that has one thing in mind: increasing customer value. The Web extra at http://youtu.be/tDl\_cHfrJZo is an audio podcast of the Tools of the Trade column discusses how continuous integration is more than a set of practices, it's a mindset that has one thing in mind: increasing customer value.},
  doi      = {10.1109/MS.2014.58},
  file     = {IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/abstract/document/6802994:text/html},
  keywords = {Internet, program testing, software engineering, software tools, source code (software), automated builds, test suite, software development, Web frameworks, source code, customer value, company shipping culture, continuous integration, Production, Servers, Monitoring, Software, Green products, Marine vehicles, Multimedia communication, continuous integration, continuous delivery, testing}
}

@article{Brandtner2015,
  author     = {Brandtner, Martin and Giger, Emanuel and Gall, Harald},
  title      = {{SQA}-{Mashup}: {A} mashup framework for continuous integration},
  journal    = {Information and Software Technology},
  year       = {2015},
  volume     = {65},
  pages      = {97--113},
  month      = sep,
  issn       = {0950-5849},
  abstract   = {Context
Continuous Integration (CI) has become an established best practice of modern software development. Its philosophy of regularly integrating the changes of individual developers with the master code base saves the entire development team from descending into Integration Hell, a term coined in the field of extreme programming. In practice, CI is supported by automated tools to cope with this repeated integration of source code through automated builds and testing. One of the main problems, however, is that relevant information about the quality and health of a software system is both scattered across those tools and across multiple views.
Objective
This paper introduces a quality awareness framework for CI-data and its conceptional model used for the data integration and visualization. The framework called SQA-Mashup makes use of the service-based mashup paradigm and integrates information from the entire CI-toolchain into a single service.
Method
The research approach followed in our work consists out of (i) a conceptional model for data integration and visualization, (ii) a prototypical framework implementation based on tool requirements derived from literature, and (iii) a controlled user study to evaluate its usefulness.
Results
The results of the controlled user study showed that SQA-Mashup’s single point of access allows users to answer questions regarding the state of a system more quickly (57\%) and accurately (21.6\%) than with standalone CI-tools.
Conclusions
The SQA-Mashup framework can serve as one-stop shop for software quality data monitoring in a software development project. It enables easy access to CI-data which otherwise is not integrated but scattered across multiple CI-tools. Our dynamic visualization approach allows for a tailoring of integrated CI-data according to information needs of different stakeholders such as developers or testers.},
  comment    = {This one is key and I found it throuhg the more comprenhensive litrature review},
  doi        = {10.1016/j.infsof.2014.10.004},
  file       = {ScienceDirect Snapshot:https\://www.sciencedirect.com/science/article/pii/S0950584914002158:text/html;ScienceDirect Full Text PDF:https\://pdf.sciencedirectassets.com/271539/1-s2.0-S0950584915X00061/1-s2.0-S0950584914002158/main.pdf?X-Amz-Security-Token=AgoJb3JpZ2luX2VjEIr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLWVhc3QtMSJGMEQCIF1%2BjWBjRuK%2B3M%2FcYssZMJ%2B6dzoicVFod8YK85BUau8kAiAVWaa6RgiwnYq8Ll7Jo535FMlaUwtOmhy0b8EXvNtbGSraAwhzEAIaDDA1OTAwMzU0Njg2NSIMlXiSV5D8yMl6i2mwKrcDY0kJWlGztIHKR7tOB3r73bft%2FZgfns7Z%2BRyQSjLnvYFmdxkHzJvK6xkgfAqaCV%2BN%2F3oEywpeqz13gHjk81C02MBEklUoNZ6ioHaqbNetUcg%2F3DwBP%2F%2BdoY8t40xlcGfLpE2xnmFKPbotiOv664DoqdIHPqzHMjLRHyNDA5kOWO8CbxKYjzsy9pEL8TDG6AJ45NDHf6wNGBzfdKde1EU%2BoRtn7NGKCFEf00lOYA4NunSXXf608b%2FM1RzF5KBuTqRMkUEhF9Fis7NV2cFC2OBjhJ6pZREBwNPCB4I68ZwkhiyVzInztoNPcZAqSmp6C5o%2FsSW9m9W%2FgwQI6qegd4lt5JV%2FiqGXVyOQbB1CiwE2J82tdq0A7bsFh5IvoCAHCpMk7zb7xHF1r3lBDeaH7B83K5YKx0itxG9g6UYyZ6D%2BhNHurO0IDQ6KtDWEjTpH2ZaV8FyIghdrwtThZfmAqrJbuEqNvZK6SlXilOTupfE8pQgK9mle1nIf02OrmAIWIBCLQZGfRMgAloVUdlZ3tgUxynYny2hYja5G%2BNw5JU9R4vddafLiTSstzYol4hsGhbujhHFE6eznpjDljOzsBTq1AfrUqzcZlxN92Yf5K8b8McF%2FkI47QiOFJ1a%2FDLVzzqnAo5vsexbsuvfSD%2B3TafjCGa%2BYrX8diJvjTp9i%2F7CcL0LlrlmWBC8gQ2hTryMuvJLzbsFqrmWAhV80BZ1NwIvxcng8gu4vApq5k6bT18Fxx7zJU5dnc7oAXmTGNCM07ZxjwbYULcBNqdgD7Fzb7XCzA17wydOoVbIUNU5t3RqojhgwSlVXxUhtRmE6l%2Bt9PcU1kjSpqUU%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20191007T105904Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYZUQMMY3W%2F20191007%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=03675afe0d193546bcc9a50b88664fc305a8aa126f9e214c76db1880907032bc&hash=30d27ec157db48079d47764147f0cb004911a4cd804a88ae46bb098d07788862&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0950584914002158&tid=spdf-c23e6da5-50a0-4fcd-99d6-f2a663a74103&sid=0da2e4661aeac748f32af9184bb9c926564agxrqb&type=client:application/pdf},
  keywords   = {Continuous integration, Controlled user study, Software quality, Tool integration, Information needs},
  shorttitle = {{SQA}-{Mashup}},
  url        = {http://www.sciencedirect.com/science/article/pii/S0950584914002158},
  urldate    = {2019-10-07TZ}
}

@inproceedings{Alegroth2018,
  author     = {Alégroth, E. and Karlsson, A. and Radway, A.},
  title      = {Continuous {Integration} and {Visual} {GUI} {Testing}: {Benefits} and {Drawbacks} in {Industrial} {Practice}},
  booktitle  = {2018 {IEEE} 11th {International} {Conference} on {Software} {Testing}, {Verification} and {Validation} ({ICST})},
  year       = {2018},
  pages      = {172--181},
  month      = apr,
  abstract   = {Continuous integration (CI) is growing in industrial popularity, spurred on by market trends towards faster delivery and higher quality software. A key facilitator of CI is automated testing that should be executed, automatically, on several levels of system abstraction. However, many systems lack the interfaces required for automated testing. Others lack test automation coverage of the system under test's (SUT) graphical user interface (GUI) as it is shown to the user. One technique that shows promise to solve these challenges is Visual GUI Testing (VGT), which uses image recognition to stimulate and assert the SUT's behavior. Research has presented the technique's applicability and feasibility in industry but only limited support, from an academic setting, that the technique is applicable in a CI environment. In this paper we presents a study from an industrial design research study with the objective to help bridge the gap in knowledge regarding VGT's applicability in a CI environment in industry. Results, acquired from interviews, observations and quantitative analysis of 17.567 test executions, collected over 16 weeks, show that VGT provides similar benefits to other automated test techniques for CI. However, several significant drawbacks, such as high costs, are also identified. The study concludes that, although VGT is applicable in an industrial CI environment, its severe challenges require more research and development before the technique becomes efficient in practice.},
  doi        = {10.1109/ICST.2018.00026},
  file       = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/ielx7/8365877/8367020/08367046.pdf?tp=&arnumber=8367046&isnumber=8367020&ref=:application/pdf;IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/abstract/document/8367046:text/html},
  keywords   = {graphical user interfaces, image recognition, program testing, software quality, industrial design research study, automated test techniques, industrial CI environment, continuous integration, visual GUI testing, industrial practice, industrial popularity, system abstraction, automated testing, test automation coverage, test executions, software quality, SUT behavior, VGT applicability, system under test, image recognition, Testing, Tools, Companies, Graphical user interfaces, Software, Image recognition, Visualization, Visual GUI Testing, Continuous Integration, Industrial Study, Empirical, Design Research},
  shorttitle = {Continuous {Integration} and {Visual} {GUI} {Testing}}
}

@article{Alegroth2016,
  author     = {Alégroth, Emil and Feldt, Robert and Kolström, Pirjo},
  title      = {Maintenance of {Automated} {Test} {Suites} in {Industry}: {An} {Empirical} study on {Visual} {GUI} {Testing}},
  journal    = {arXiv:1602.01226 [cs]},
  year       = {2016},
  month      = feb,
  note       = {arXiv: 1602.01226},
  abstract   = {Context: Verification and validation (V\&V) activities make up 20 to 50 percent of the total development costs of a software system in practice. Test automation is proposed to lower these V\&V costs but available research only provides limited empirical data from industrial practice about the maintenance costs of automated tests and what factors affect these costs. In particular, these costs and factors are unknown for automated GUI-based testing. Objective: This paper addresses this lack of knowledge through analysis of the costs and factors associated with the maintenance of automated GUI-based tests in industrial practice. Method: An empirical study at two companies, Siemens and Saab, is reported where interviews about, and empirical work with, Visual GUI Testing is performed to acquire data about the technique's maintenance costs and feasibility. Results: 13 factors are observed that affect maintenance, e.g. tester knowledge/experience and test case complexity. Further, statistical analysis shows that developing new test scripts is costlier than maintenance but also that frequent maintenance is less costly than infrequent, big bang maintenance. In addition a cost model, based on previous work, is presented that estimates the time to positive return on investment (ROI) of test automation compared to manual testing. Conclusions: It is concluded that test automation can lower overall software development costs of a project whilst also having positive effects on software quality. However, maintenance costs can still be considerable and the less time a company currently spends on manual testing, the more time is required before positive, economic, ROI is reached after automation.},
  file       = {arXiv\:1602.01226 PDF:http\://www.arxiv.org/pdf/1602.01226.pdf:application/pdf;arXiv.org Snapshot:http\://arxiv.org/abs/1602.01226:text/html},
  keywords   = {Computer Science - Software Engineering},
  shorttitle = {Maintenance of {Automated} {Test} {Suites} in {Industry}},
  url        = {http://arxiv.org/abs/1602.01226},
  urldate    = {2019-10-15TZ}
}


@inproceedings{Hilton2016,
author = {Hilton, Michael and Tunnell, Timothy and Huang, Kai and Marinov, Darko and Dig, Danny},
title = {Usage, Costs, and Benefits of Continuous Integration in Open-Source Projects},
year = {2016},
isbn = {9781450338455},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2970276.2970358},
doi = {10.1145/2970276.2970358},
abstract = { Continuous integration (CI) systems automate the compilation, building, and testing of software. Despite CI rising as a big success story in automated software engineering, it has received almost no attention from the research community. For example, how widely is CI used in practice, and what are some costs and benefits associated with CI? Without answering such questions, developers, tool builders, and researchers make decisions based on folklore instead of data. In this paper, we use three complementary methods to study the usage of CI in open-source projects. To understand which CI systems developers use, we analyzed 34,544 open-source projects from GitHub. To understand how developers use CI, we analyzed 1,529,291 builds from the most commonly used CI system. To understand why projects use or do not use CI, we surveyed 442 developers. With this data, we answered several key questions related to the usage, costs, and benefits of CI. Among our results, we show evidence that supports the claim that CI helps projects release more often, that CI is widely adopted by the most popular projects, as well as finding that the overall percentage of projects using CI continues to grow, making it important and timely to focus more research on CI. },
booktitle = {Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering},
pages = {426–437},
numpages = {12},
keywords = {mining software repositories, continuous integration},
location = {Singapore, Singapore},
series = {ASE 2016}
}

  



@article{Gallaba2018,
  author     = {Gallaba, Keheliya and McIntosh, Shane},
  title      = {Use and {Misuse} of {Continuous} {Integration} {Features}: {An} {Empirical} {Study} of {Projects} that (mis)use {Travis} {CI}},
  journal    = {IEEE Transactions on Software Engineering},
  year       = {2018},                
  pages      = {1--1},
  issn       = {2326-3881},
  abstract   = {Continuous Integration (CI) is a popular practice where software systems are automatically compiled and tested as changes appear in the version control system of a project. Like other software artifacts, CI specifications require maintenance effort. Although there are several service providers like Travis CI offering various CI features, it is unclear which features are being (mis)used. In this paper, we present a study of feature use and misuse in 9,312 open source systems that use Travis CI. Analysis of the features that are adopted by projects reveals that explicit deployment code is rare—48.16\% of the studied Travis CI specification code is instead associated with configuring job processing nodes. To analyze feature misuse, we propose Hansel—an anti-pattern detection tool for Travis CI specifications. We define four anti-patterns and Hansel detects anti-patterns in the Travis CI specifications of 894 projects in the corpus (9.60\%), and achieves a recall of 82.76\% in a sample of 100 projects. Furthermore, we propose Gretel—an anti-pattern removal tool for Travis CI specifications, which can remove 69.60\% of the most frequently occurring anti-pattern automatically. Using Gretel, we have produced 36 accepted pull requests that remove Travis CI anti-patterns automatically.},
  doi        = {10.1109/TSE.2018.2838131},
  file       = {IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/abstract/document/8360943:text/html},
  keywords   = {Tools, Organizations, Software, Computer languages, Control systems, Electronic mail, Feature extraction},
  shorttitle = {Use and {Misuse} of {Continuous} {Integration} {Features}}
}

@inproceedings{Jiang2015,
  author    = {Jiang, Yujuan and Adams, Bram},
  title     = {Co-evolution of {Infrastructure} and {Source} {Code} - {An} {Empirical} {Study}},
  booktitle = {2015 {IEEE}/{ACM} 12th {Working} {Conference} on {Mining} {Software} {Repositories}},
  year      = {2015},
  pages     = {45--55},
  month     = may,
  note      = {ISSN: 2160-1860},
  abstract  = {Infrastructure-as-code automates the process of configuring and setting up the environment (e.g., servers, VMs and databases) in which a software system will be tested and/or deployed, through textual specification files in a language like Puppet or Chef. Since the environment is instantiated automatically by the infrastructure languages' tools, no manual intervention is necessary apart from maintaining the infrastructure specification files. The amount of work involved with such maintenance, as well as the size and complexity of infrastructure specification files, have not yet been studied empirically. Through an empirical study of the version control system of 265 Open Stack projects, we find that infrastructure files are large and churn frequently, which could indicate a potential of introducing bugs. Furthermore, we found that the infrastructure code files are coupled tightly with the other files in a project, especially test files, which implies that testers often need to change infrastructure specifications when making changes to the test framework and tests.},
  doi       = {10.1109/MSR.2015.12},
  file      = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/ielx7/7180033/7180053/07180066.pdf?tp=&arnumber=7180066&isnumber=7180053&ref=:application/pdf;IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/document/7180066:text/html},
  issn      = {2160-1860},
  keywords  = {formal specification, source code (software), infrastructure coevolution, source code, infrastructure code files, infrastructure specifications, Couplings, Measurement, Association rules, Servers, Cloud computing, Maintenance engineering}
}

@inproceedings{Ikeshita2017,
  author    = {Ikeshita, Katsuhiko and Ishikawa, Fuyuki and Honiden, Shinichi},
  title     = {Test {Suite} {Reduction} in {Idempotence} {Testing} of {Infrastructure} as {Code}},
  booktitle = {Tests and {Proofs}},
  year      = {2017},
  editor    = {Gabmeyer, Sebastian and Johnsen, Einar Broch},
  series    = {Lecture {Notes} in {Computer} {Science}},
  pages     = {98--115},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {Infrastructure as Code, which uses machine-processable code for managing, provisioning, and configuring computing infrastructure, has been attracting wide attention. In its application, the idempotence of the code is essential: the system should converge to the desired state even if the code is repeatedly executed possibly with failures or interruptions. Previous studies have used testing or static verification techniques to check whether the code is idempotent or not. The testing approach is impractically time-consuming, whereas the static verification approach is not applicable in many practical cases in which external scripts are used. In this paper, we present a method for efficiently checking idempotence by combining the testing and static verification approaches. The method dramatically decreases the number of test cases used to check code including external scripts by applying the static verification approach.},
  doi       = {10.1007/978-3-319-61467-0_6},
  file      = {Springer Full Text PDF:https\://link.springer.com/content/pdf/10.1007%2F978-3-319-61467-0_6.pdf:application/pdf},
  isbn      = {9783319614670},
  keywords  = {Execution Time , Outgoing Edge , Source Language , Satisfiability Modulo Theory , Incoming Edge },
  language  = {en}
}

@inproceedings{Guerriero2019,
  author     = {Guerriero, MIchele and Garriga, Martin and Tamburri, Damian A. and Palomba, Fabio},
  title      = {Adoption, {Support}, and {Challenges} of {Infrastructure}-as-{Code}: {Insights} from {Industry}},
  booktitle  = {2019 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
  year       = {2019},
  pages      = {580--589},
  month      = sep,
  note       = {ISSN: 1063-6773},
  abstract   = {Infrastructure-as-code (IaC) is the DevOps tactic of managing and provisioning infrastructure through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools. From a maintenance and evolution perspective, the topic has picked the interest of practitioners and academics alike, given the relative scarcity of supporting patterns, best practices, tools, and software engineering techniques. Using the data coming from 44 semistructured interviews to senior developers of as many companies, in this paper we shed light on the state of the practice in the adoption of IaC and the key software engineering challenges in the field. Particularly, we investigate (i) how practitioners adopt and develop IaC, (ii) which support is currently available, i.e., the typically used tools and their advantages/disadvantages, and (iii) what are the practitioner's needs when dealing with IaC development, maintenance, and evolution. Our findings clearly highlight the need for more research in the field: the support provided by currently available tools is still limited, and developers feel the need of novel techniques for testing and maintaining IaC code.},
  doi        = {10.1109/ICSME.2019.00092},
  file       = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/ielx7/8910135/8918933/08919181.pdf?tp=&arnumber=8919181&isnumber=8918933&ref=:application/pdf;IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/document/8919181:text/html},
  issn       = {1063-6773},
  keywords   = {Tools, Interviews, Companies, Cloud computing, Software maintenance, Maintenance engineering, Infrastructure-as-Code, DevOps, Software Maintenance \& Evolution, Cloud Automation},
  shorttitle = {Adoption, {Support}, and {Challenges} of {Infrastructure}-as-{Code}}
}

@inproceedings{Rahman2018b,
  author    = {Rahman, Akond and Williams, Laurie},
  title     = {Characterizing {Defective} {Configuration} {Scripts} {Used} for {Continuous} {Deployment}},
  booktitle = {2018 {IEEE} 11th {International} {Conference} on {Software} {Testing}, {Verification} and {Validation} ({ICST})},
  year      = {2018},
  pages     = {34--45},
  month     = apr,
  note      = {ISSN: null},
  abstract  = {In software engineering, validation and verification (V\&V) resources are limited and characterization of defective software source files can help in efficiently allocating V\&V resources. Similar to software source files, defects occur in the scripts used to automatically manage configurations and software deployment infrastructure, often known as infrastructure as code (IaC) scripts. Defects in IaC scripts can have dire consequences, for example, creating large-scale system outages. Identifying the characteristics of defective IaC scripts can help in mitigating these defects by allocating V\&V efforts efficiently based upon these characteristics. The objective of this paper is to help software practitioners to prioritize validation and verification efforts for infrastructure as code (IaC) scripts by identifying the characteristics of defective IaC scripts. Researchers have previously extracted text features to characterize defective software source files written in general purpose programming languages. We investigate if text features can be used to identify properties that characterize defective IaC scripts. We use two text mining techniques to extract text features from IaC scripts: the bag-of-words technique, and the term frequency-inverse document frequency (TF-IDF) technique. Using the extracted features and applying grounded theory, we characterize defective IaC scripts. We also use the text features to build defect prediction models with tuned statistical learners. We mine open source repositories from Mozilla, Openstack, and Wikimedia Commons, to construct three case studies and evaluate our methodology. We identify three properties that characterize defective IaC scripts: filesystem operations, infrastructure provisioning, and managing user accounts. Using the bag-of-word technique, we observe a median F-Measure of 0.74, 0.71, and 0.73, respectively, for Mozilla, Openstack, and Wikimedia Commons. Using the TF-IDF technique, we observe a median F-Measure of 0.72, 0.74, and 0.70, respectively, for Mozilla, Openstack, and Wikimedia Commons.},
  doi       = {10.1109/ICST.2018.00014},
  file      = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/ielx7/8365877/8367020/08367034.pdf?tp=&arnumber=8367034&isnumber=8367020&ref=:application/pdf;IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/abstract/document/8367034:text/html},
  issn      = {null},
  keywords  = {data mining, program verification, resource allocation, software engineering, software fault tolerance, text analysis, defective IaC scripts, defective software source files, code scripts, user account management, infrastructure provisioning, filesystem operations, term frequency-inverse document frequency, bag-of-words technique, text mining, V\&V resource allocation, validation and verification resources, defective configuration scripts, text feature extraction, Feature extraction, Software, Predictive models, Text mining, Organizations, Measurement, DSL, configuration as code, continuous deployment, defect, devops, infrastructure as code, puppet}
}

@misc{,
  title      = {What questions do programmers ask about configuration as code? {\textbar} {Proceedings} of the 4th {International} {Workshop} on {Rapid} {Continuous} {Software} {Engineering}},
  file       = {Snapshot:https\://dl.acm.org/doi/10.1145/3194760.3194769:text/html},
  language   = {EN},
  shorttitle = {What questions do programmers ask about configuration as code?},
  url        = {https://dl.acm.org/doi/abs/10.1145/3194760.3194769},
  urldate    = {CURRENT\_TIMESTAMP}
}

@inproceedings{Bagnato2018,
  author    = {Bagnato, Alessandra and Barmpis, Konstantinos and Bessis, Nik and Cabrera-Diego, Luis Adrián and Di Rocco, Juri and Di Ruscio, Davide and Gergely, Tamás and Hansen, Scott and Kolovos, Dimitris and Krief, Philippe and Korkontzelos, Ioannis and Laurière, Stéphane and Lopez de la Fuente, Jose Manrique and Maló, Pedro and Paige, Richard F. and Spinellis, Diomidis and Thomas, Cedric and Vinju, Jurgen},
  title     = {Developer-{Centric} {Knowledge} {Mining} from {Large} {Open}-{Source} {Software} {Repositories} ({CROSSMINER})},
  booktitle = {Software {Technologies}: {Applications} and {Foundations}},
  year      = {2018},
  editor    = {Seidl, Martina and Zschaler, Steffen},
  series    = {Lecture {Notes} in {Computer} {Science}},
  pages     = {375--384},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {Deciding if an OSS project meets the required standards for adoption is hard, and keeping up-to-date with a rapidly evolving project is even harder. Making decisions about quality and adoption involves analysing code, documentation, online discussions, and issue trackers. There is too much information to process manually and it is common that uninformed decisions have to be made with detrimental effects. CROSSMINER aims to remedy this by automatically extracting the required knowledge and injecting it into the developers’ Integrated Development Environments (IDE), at the time they need it to make design decisions. This allows them to reduce their effort in knowledge acquisition and to increase the quality of their code. CROSSMINER uniquely combines advanced software project analyses with online IDE monitoring. Developers will be monitored to infer which information is timely, based on readily available knowledge stored earlier by a set of advanced offline deep analyses of related OSS projects.},
  doi       = {10.1007/978-3-319-74730-9_33},
  file      = {Springer Full Text PDF:https\://link.springer.com/content/pdf/10.1007%2F978-3-319-74730-9_33.pdf:application/pdf},
  isbn      = {9783319747309},
  language  = {en}
}

@inproceedings{Rahman2018,
  author    = {Rahman, Akond and Partho, Asif and Morrison, Patrick and Williams, Laurie},
  title     = {What {Questions} {Do} {Programmers} {Ask} about {Configuration} as {Code}?},
  booktitle = {2018 {IEEE}/{ACM} 4th {International} {Workshop} on {Rapid} {Continuous} {Software} {Engineering} ({RCoSE})},
  year      = {2018},
  pages     = {16--22},
  month     = may,
  note      = {ISSN: null},
  abstract  = {Configuration as code (CaC) tools, such as Ansible and Puppet, help software teams to implement continuous deployment and deploy software changes rapidly. CaC tools are growing in popularity, yet what challenges programmers encounter about CaC tools, have not been characterized. A systematic investigation on what questions are asked by programmers, can help us identify potential technical challenges about CaC, and can aid in successful use of CaC tools. The goal of this paper is to help current and potential configuration as code (CaC) adoptees in identifying the challenges related to CaC through an analysis of questions asked by programmers on a major question and answer website. We extract 2,758 Puppet-related questions asked by programmers from January 2010 to December 2016, posted on Stack Overflow. We apply qualitative analysis to identify the questions programmers ask about Puppet. We also investigate the trends in questions with unsatisfactory answers, and changes in question categories over time. From our empirical study, we synthesize 16 major categories of questions. The three most common question categories are: (i) syntax errors, (ii) provisioning instances; and (iii) assessing Puppet's feasibility to accomplish certain tasks. Three categories of questions that yield the most unsatisfactory answers are (i) installation, (ii) security, and (iii) data separation.},
  file      = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/ielx7/8451857/8452090/08452102.pdf?tp=&arnumber=8452102&isnumber=8452090&ref=:application/pdf;IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/abstract/document/8452102:text/html},
  issn      = {null},
  keywords  = {software maintenance, software tools, challenges programmers, CaC tools, potential technical challenges, current configuration, potential configuration, Puppet-related questions, common question categories, code tools, deploy software changes, answer Website, question programmers, Tools, Sorting, Software engineering, Software, Market research, Mathematical model, Programming, challenge, configuration as code, continuous deployment, devops, infrastructure as code, programming, puppet, question, stack overflow}
}

@article{Peng2019,
  author   = {Peng, Zhenhui and Ma, Xiaojuan},
  title    = {Exploring how software developers work with mention bot in {GitHub}},
  journal  = {CCF Transactions on Pervasive Computing and Interaction},
  year     = {2019},
  volume   = {1},
  number   = {3},
  pages    = {190--203},
  month    = nov,
  issn     = {2524-5228},
  abstract = {Recently, major software development platforms have started to provide automatic reviewer recommendation (ARR) services for pull requests to improve collaborative coding review process. However, the user experience of ARR is under-investigated. In this paper, we use a two-stage mixed-methods approach to study how software developers perceive and work with the Facebook mention bot, one of the most popular ARR bots in GitHub. Specifically, in Stage I, we conduct archival analysis on projects employing mention bot and a user survey to investigate bot performance. A year later, in Stage II, we revisit these projects and conduct additional surveys and interviews with three user groups: project owners, contributors and reviewers. Results show that developers appreciate mention bot saving their efforts, but are bothered by its unstable setting and unbalanced workload allocation. We conclude with design considerations for improving ARR services.},
  doi      = {10.1007/s42486-019-00013-2},
  file     = {Springer Full Text PDF:https\://link.springer.com/content/pdf/10.1007%2Fs42486-019-00013-2.pdf:application/pdf},
  language = {en},
  url      = {https://doi.org/10.1007/s42486-019-00013-2},
  urldate  = {2020-01-07TZ}
}

@misc{,
  title    = {A conceptual replication of continuous integration pain points in the context of {Travis} {CI} {\textbar} {Proceedings} of the 2019 27th {ACM} {Joint} {Meeting} on {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
  file     = {Snapshot:https\://dl.acm.org/doi/10.1145/3338906.3338922:text/html},
  language = {EN},
  url      = {https://dl.acm.org/doi/abs/10.1145/3338906.3338922},
  urldate  = {CURRENT\_TIMESTAMP}
}

@article{Vassallo2019,
  author     = {Vassallo, Carmine and Proksch, Sebastian and Zemp, Timothy and Gall, Harald C.},
  title      = {Every build you break: developer-oriented assistance for build failure resolution},
  journal    = {Empirical Software Engineering},
  year       = {2019},
  month      = oct,
  issn       = {1573-7616},
  abstract   = {Continuous integration is an agile software development practice. Instead of integrating features right before a release, they are constantly being integrated into an automated build process. This shortens the release cycle, improves software quality, and reduces time to market. However, the whole process will come to a halt when a commit breaks the build, which can happen for several reasons, e.g., compilation errors or test failures, and fixing the build suddenly becomes a top priority. Developers not only have to find the cause of the build break and fix it, but they have to be quick in all of it to avoid a delay for others. Unfortunately, these steps require deep knowledge and are often time-consuming. To support developers in fixing a build break, we propose Bart, a tool that summarizes the reasons for Maven build failures and suggests possible solutions found on the internet. We will show in a case study with 17 participants that developers find Bart useful to understand build breaks and that using Bart substantially reduces the time to fix a build break, on average by 37\%. We have also conducted a qualitative study to better understand the workflows and information needs when fixing builds. We found that typical workflows differ substantially between various error categories, and that several uncommon build errors are both very hard to investigate and to fix. These findings will be useful to inform future research in this area.},
  doi        = {10.1007/s10664-019-09765-y},
  file       = {Springer Full Text PDF:https\://link.springer.com/content/pdf/10.1007%2Fs10664-019-09765-y.pdf:application/pdf},
  language   = {en},
  shorttitle = {Every build you break},
  url        = {https://doi.org/10.1007/s10664-019-09765-y},
  urldate    = {2020-01-07TZ}
}

@inproceedings{,
  file = {:https\://github.blog/2017-11-07-github-welcomes-all-ci-tools/:URL}
}

@inproceedings{Github2017,
  author        = {Github},
  title         = {Github welcomes all ci tools},
  booktitle     = {Github welcomes all ci tools},
  year          = {2017},
  editor        = {github.com},
  author/editor = {github.com},
  url           = {https://github.blog/2017-11-07-github-welcomes-all-ci-tools/}
}

@inproceedings{Cito2017,
  author    = {Cito, Jürgen and Schermann, Gerald and Wittern, John Erik and Leitner, Philipp and Zumberi, Sali and Gall, Harald C.},
  title     = {An {Empirical} {Analysis} of the {Docker} {Container} {Ecosystem} on {GitHub}},
  booktitle = {2017 {IEEE}/{ACM} 14th {International} {Conference} on {Mining} {Software} {Repositories} ({MSR})},
  year      = {2017},
  pages     = {323--333},
  month     = may,
  note      = {ISSN: null},
  abstract  = {Docker allows packaging an application with its dependencies into a standardized, self-contained unit (a so-called container), which can be used for software development and to run the application on any system. Dockerfiles are declarative definitions of an environment that aim to enable reproducible builds of the container. They can often be found in source code repositories and enable the hosted software to come to life in its execution environment. We conduct an exploratory empirical study with the goal of characterizing the Docker ecosystem, prevalent quality issues, and the evolution of Dockerfiles. We base our study on a data set of over 70000 Dockerfiles, and contrast this general population with samplings that contain the Top-100 and Top-1000 most popular Docker-using projects. We find that most quality issues (28.6\%) arise from missing version pinning (i.e., specifying a concrete version for dependencies). Further, we were not able to build 34\% of Dockerfiles from a representative sample of 560 projects. Integrating quality checks, e.g., to issue version pinning warnings, into the container build process could result into more reproducible builds. The most popular projects change more often than the rest of the Docker population, with 5.81 revisions per year and 5 lines of code changed on average. Most changes deal with dependencies, that are currently stored in a rather unstructured manner. We propose to introduce an abstraction that, for instance, could deal with the intricacies of different package managers and could improve migration to more light-weight images.},
  doi       = {10.1109/MSR.2017.67},
  file      = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/ielx7/7959735/7962336/07962382.pdf?tp=&arnumber=7962382&isnumber=7962336&ref=:application/pdf;IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/document/7962382:text/html},
  issn      = {null},
  keywords  = {software engineering, source code (software), docker container ecosystem, GitHub, software development, dockerfile evolution, docker-using projects, Containers, Software, Ecosystems, Tools, Computer languages, Sociology, Statistics, empirical software engineering, GitHub, Docker}
}

@inproceedings{Kalliamvakou2014,
  author    = {Kalliamvakou, Eirini and Gousios, Georgios and Blincoe, Kelly and Singer, Leif and German, Daniel M. and Damian, Daniela},
  title     = {The promises and perils of mining {GitHub}},
  year      = {2014},
  series    = {{MSR} 2014},
  pages     = {92--101},
  address   = {Hyderabad, India},
  month     = may,
  publisher = {Association for Computing Machinery},
  abstract  = {With over 10 million git repositories, GitHub is becoming one of the most important source of software artifacts on the Internet. Researchers are starting to mine the information stored in GitHub's event logs, trying to understand how its users employ the site to collaborate on software. However, so far there have been no studies describing the quality and properties of the data available from GitHub. We document the results of an empirical study aimed at understanding the characteristics of the repositories in GitHub and how users take advantage of GitHub's main features---namely commits, pull requests, and issues. Our results indicate that, while GitHub is a rich source of data on software development, mining GitHub for research purposes should take various potential perils into consideration. We show, for example, that the majority of the projects are personal and inactive; that GitHub is also being used for free storage and as a Web hosting service; and that almost 40\% of all pull requests do not appear as merged, even though they were. We provide a set of recommendations for software engineering researchers on how to approach the data in GitHub.},
  doi       = {10.1145/2597073.2597074},
  file      = {Full Text PDF:https\://dl.acm.org/doi/pdf/10.1145/2597073.2597074?download=true:application/pdf},
  isbn      = {9781450328630},
  keywords  = {Mining software repositories, git, code reviews, github, bias},
  url       = {https://doi.org/10.1145/2597073.2597074},
  urldate   = {2020-01-27}
}

@article{Staahl2014,
  author   = {Ståhl, Daniel and Bosch, Jan},
  title    = {Modeling continuous integration practice differences in industry software development},
  journal  = {Journal of Systems and Software},
  year     = {2014},
  volume   = {87},
  pages    = {48--59},
  month    = jan,
  issn     = {0164-1212},
  abstract = {Continuous integration is a software practice where developers integrate frequently, at least daily. While this is an ostensibly simple concept, it does leave ample room for interpretation: what is it the developers integrate with, what happens when they do, and what happens before they do? These are all open questions with regards to the details of how one implements the practice of continuous integration, and it is conceivable that not all such implementations in the industry are alike. In this paper we show through a literature review that there are differences in how the practice of continuous integration is interpreted and implemented from case to case. Based on these findings we propose a descriptive model for documenting and thereby better understanding implementations of the continuous integration practice and their differences. The application of the model to an industry software development project is then described in an illustrative case study.},
  doi      = {10.1016/j.jss.2013.08.032},
  file     = {ScienceDirect Snapshot:https\://www.sciencedirect.com/science/article/pii/S0164121213002276:text/html;ScienceDirect Full Text PDF:https\://pdf.sciencedirectassets.com/271629/1-s2.0-S0164121213X00123/1-s2.0-S0164121213002276/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAsaCXVzLWVhc3QtMSJIMEYCIQCj52vs88Puhp9fg0uHSC3lb3KLql8MrPPiB9%2Bt5QvkQAIhAJGGshN%2F5%2BdOVIAVYDn2S46jgNTK4l9EqhGXIVXVaaJlKr0DCKT%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAhoMMDU5MDAzNTQ2ODY1IgzIDgsexe4dKcxuZRgqkQOxjKNUlNuPMpxc9%2FCSg9CEoFDcUf2EF9KVWlJeYDFFY%2FHOQp%2BnhTagEzLtE9YU%2BYP0Dtsi0fcnnoYB0WAhlQqWJsJDmyk2OmPyuDR65SJDvDeY9lO0MOzJH3d6uM0Bmqm9tGNHTaLTfqzheWyTaFD1skAeKEXjl%2F6brEAbwLnXUJotOChuvCjVEKEylpEEjRT%2Bs5amvC8cEeohD2%2Ft8K9gM%2FjhdMAmqGdwYVLZXokdUb88nVeVUH1I9QM0u5RTIn77DH44Pz9I0W2YiDPFED78HE3lnE1IYc3ekmEhK4HQTKDZ%2FtfbLRnMLHhHKx2mfN8HWJu1wxrYYV62gyeQjeN1trfjewWYm1v11JKp7qNT22w%2Bqc%2FDE4evg9%2FXYAreHr8rSPWi59VJ77rusNqI%2FUhu519LGLbm16rZqm3WjKI356A0V5%2F49mnfBQY6auogVTWAEewb%2BApctVMGyfzuzu0zRfTDuFCCiioos%2BEXEz4YcmJjEqwYsncCQvQhzLTmopL23zDPMGOoIox1AD2t7JOHsDD6hLvxBTrqAd1NN%2FDypjhDQyWORxA0DXpgs8V5jEkkNKl5yISF7fT0SQP3Y6DybXWSWqfy%2FN%2BY29KQmTQ66qxs%2Fg4HWVO5rp%2BEKjdnUX2Csm7EFFnAeJVZOPlpRRcn9j4Iac4vHb13HEH7NBNQ%2BxoQJDx9uleWEwtgjT9nbPcw%2BR44rc7qJxOyl1VByIoMWuWocQ09W7sQ6sjBFQ9L0sLwTaimRPkLkOPDW%2FN6ItrcGsD20jrbohWpQUx5yhwzzp8Wd9sV%2FJRt6uVdE2xPm9VumPLrOtIpAx1zIz3FLbguq6qAd%2BZ%2F%2Fc4WRp%2FI9NrR%2BPCT5g%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20200127T122945Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYUL24TKNY%2F20200127%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=923f9a17cd97be8deeefee538f8da970ee3685be981c9d9d3937d4d3c7305d6b&hash=c78250a0f926ccb7dad9c7a5f3f580fc939df3aa6a75d5149c3c08f7b5d169ad&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0164121213002276&tid=spdf-24817253-1ae4-49f8-9394-4a8c921c7d14&sid=cf2ff155874b114df198f7608cab50bdf035gxrqb&type=client:application/pdf},
  keywords = {Continuous integration, Agile software development},
  language = {en},
  url      = {http://www.sciencedirect.com/science/article/pii/S0164121213002276},
  urldate  = {2020-01-27TZ}
}

@Article{Staahl2014a,
  author   = {Ståhl, Daniel and Bosch, Jan},
  title    = {Modeling continuous integration practice differences in industry software development},
  journal  = {Journal of Systems and Software},
  year     = {2014},
  volume   = {87},
  pages    = {48--59},
  month    = jan,
  issn     = {0164-1212},
  abstract = {Continuous integration is a software practice where developers integrate frequently, at least daily. While this is an ostensibly simple concept, it does leave ample room for interpretation: what is it the developers integrate with, what happens when they do, and what happens before they do? These are all open questions with regards to the details of how one implements the practice of continuous integration, and it is conceivable that not all such implementations in the industry are alike. In this paper we show through a literature review that there are differences in how the practice of continuous integration is interpreted and implemented from case to case. Based on these findings we propose a descriptive model for documenting and thereby better understanding implementations of the continuous integration practice and their differences. The application of the model to an industry software development project is then described in an illustrative case study.},
  doi      = {10.1016/j.jss.2013.08.032},
  file     = {ScienceDirect Snapshot:https\://www.sciencedirect.com/science/article/pii/S0164121213002276:text/html;ScienceDirect Full Text PDF:https\://pdf.sciencedirectassets.com/271629/1-s2.0-S0164121213X00123/1-s2.0-S0164121213002276/main.pdf?X-Amz-Security-Token=IQoJb3JpZ2luX2VjEAwaCXVzLWVhc3QtMSJHMEUCIDfmvOIaSxVB9GDiIQNzB7mbOgya2MczfS5dlW%2BASq47AiEAwxhGN8qckPtMBCrkEbJA9nLj14zsHqjDypJoOiYnShEqvQMIpP%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARACGgwwNTkwMDM1NDY4NjUiDMB71%2B5inF%2BCOwOeeSqRAw3UtXlyDboPI4JLHSIX65K3tHsr%2FY3VQfp%2FP6c6WmqUNu7gCJZTfTsteWHJqFjeSZIZyq%2B1DJGtK6fkN0yd2jUmt6cGSZGZdQ3sg4o1yT98FgC4d2Wr5M3D4uBUbWVeFGo%2FIpR%2FPBU%2BprDM41MkoRzzy6T%2F%2Bk%2FE4ZNnroFSD2764%2BNfKV9KxcFO2Lv7r3GLv3gnUr%2BH7ayDIHhh98i3PAQTTFCRgJ2s5HkwI5V9DepiTJqYI1ruHncKzI%2BiIquEZo6ae3%2FA7xTaCnqeAu7lGE918j0T0lw%2FMLjwLHK5950T%2BeLd628z1tMepCH63hIVFvzKDNzzbJ2Gy1qqrGc0Kljolm77x0uUJXYI4mcsukjhXxcUsHKqLYNK%2FBenBsefF0kxRHu2BL5YSik75xF9MGxbHvh42BdGkxwkNNsEAHA2gg5Q%2B6JDjeL0a3ygn2iPLlPLbxzGELE35yKv62Gp9jhdwCsClM%2F0cAYSWrQKhV8w%2FEMG3IfhSZ1KG%2BBrEZwJMAwY7LAWTnIGhqn8ZMuFHdxQML%2BIu%2FEFOusB7eHUD65PVYiZW4%2B17CN1OcmpSk%2FrP%2FNHAKTPwgMVdHYnv1MyL5Kp3E3b5ZlHwCPme4FQvgU%2Bzfv6Qnqn%2FJHY1MqQKj14mSqvRsILvFrRkciq1OkP28JKfG3gdJXGgCRt39Ge7RF%2BtqXmhNrXo9WlS9cC8i2nKIxVE1AGV6HXCmxsbdLSemAi32ZPAyejv33Jt2w9k81eyixCC%2FVDUEO2YNonETpQ7zegSBBDOORXIQxeu40btd%2F%2B6zviHR5twyT6GaI4i15Fn%2B05Muku53fsEoAFtpcuNAzCtVVA5byMu1KvEXITxfBiisHD7g%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Date=20200127T122929Z&X-Amz-SignedHeaders=host&X-Amz-Expires=300&X-Amz-Credential=ASIAQ3PHCVTYXPCYFNOH%2F20200127%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Signature=e2b99b2c72355a5311a0bad6123360bf368cfb008663aae85dbf1ac079ea963a&hash=398bb1694e53024e7b0f80b467efed90c3d88b3bc5e6e115267adc9575b78f58&host=68042c943591013ac2b2430a89b270f6af2c76d8dfd086a07176afe7c76c2c61&pii=S0164121213002276&tid=spdf-ce1f3700-17fc-4aa6-95df-612b14e8ad07&sid=cf2ff155874b114df198f7608cab50bdf035gxrqb&type=client:application/pdf},
  keywords = {Continuous integration, Agile software development},
  language = {en},
  url      = {http://www.sciencedirect.com/science/article/pii/S0164121213002276},
  urldate  = {2020-01-27TZ},
}

@Article{Shahin2017,
  author     = {Shahin, Mojtaba and Ali Babar, Muhammad and Zhu, Liming},
  journal    = {IEEE Access},
  title      = {Continuous {Integration}, {Delivery} and {Deployment}: {A} {Systematic} {Review} on {Approaches}, {Tools}, {Challenges} and {Practices}},
  year       = {2017},
  issn       = {2169-3536},
  pages      = {3909--3943},
  volume     = {5},
  abstract   = {Continuous practices, i.e., continuous integration, delivery, and deployment, are the software development industry practices that enable organizations to frequently and reliably release new features and products. With the increasing interest in the literature on continuous practices, it is important to systematically review and synthesize the approaches, tools, challenges, and practices reported for adopting and implementing continuous practices. This paper aimed at systematically reviewing the state of the art of continuous practices to classify approaches and tools, identify challenges and practices in this regard, and identify the gaps for future research. We used the systematic literature review method for reviewing the peer-reviewed papers on continuous practices published between 2004 and June 1, 2016. We applied the thematic analysis method for analyzing the data extracted from reviewing 69 papers selected using predefined criteria. We have identified 30 approaches and associated tools, which facilitate the implementation of continuous practices in the following ways: (1) reducing build and test time in continuous integration (CI); (2) increasing visibility and awareness on build and test results in CI; (3) supporting (semi-) automated continuous testing; (4) detecting violations, flaws, and faults in CI; (5) addressing security and scalability issues in deployment pipeline; and (6) improving dependability and reliability of deployment process. We have also determined a list of critical factors, such as testing (effort and time), team awareness and transparency, good design principles, customer, highly skilled and motivated team, application domain, and appropriate infrastructure that should be carefully considered when introducing continuous practices in a given organization. The majority of the reviewed papers were validation (34.7\%) and evaluation (36.2\%) research types. This paper also reveals that continuous practices have been successfully applied to both greenfield and maintenance projects. Continuous practices have become an important area of software engineering research and practice. While the reported approaches, tools, and practices are addressing a wide range of challenges, there are several challenges and gaps, which require future research work for improving the capturing and reporting of contextual information in the studies reporting different aspects of continuous practices; gaining a deep understanding of how software-intensive systems should be (re-) architected to support continuous practices; and addressing the lack of knowledge and tools for engineering processes of designing and running secure deployment pipelines.},
  doi        = {10.1109/ACCESS.2017.2685629},
  file       = {IEEE Xplore Full Text PDF:https\://ieeexplore.ieee.org/ielx7/6287639/7859429/07884954.pdf?tp=&arnumber=7884954&isnumber=7859429&ref=:application/pdf;IEEE Xplore Abstract Record:https\://ieeexplore.ieee.org/document/7884954:text/html},
  groups     = {[Joe:]},
  keywords   = {program testing, software fault tolerance, software houses, software maintenance, software engineering, software-intensive systems, maintenance projects, greenfield projects, design principles, transparency, team awareness, critical factors, deployment process dependability improvement, deployment process reliability improvement, scalability issues, security issues, fault detection, flaw detection, violation detection, semiautomated continuous testing, CI, test time reduction, build time reduction, thematic analysis method, continuous practices, systematic literature review method, software development industry practices, software deployment, software delivery, continuous integration, Software, Organizations, Software engineering, Systematics, Bibliographies, Testing, Production, Continuous integration, continuous delivery, continuous deployment, continuous software engineering, systematic literature review, empirical software engineering},
  shorttitle = {Continuous {Integration}, {Delivery} and {Deployment}},
}

@InProceedings{JenkkinsDocs2020,
  author    = {Jenkins},
  title     = {https://jenkins.io/doc/book/pipeline/development/},
  booktitle = {Jenkins documentation},
  year      = {2020},
}

@InProceedings{GitlabDocs2020,
  author    = {Gitlab},
  title     = {https://docs.gitlab.com/ee/api/lint.html},
  booktitle = {Gitlab docs},
  year      = {2020},
}

@InProceedings{Vasilescu2015,
  author    = {Vasilescu, Bogdan and Yu, Yue and Wang, Huaimin and Devanbu, Premkumar and Filkov, Vladimir},
  title     = {Quality and productivity outcomes relating to continuous integration in {GitHub}},
  year      = {2015},
  address   = {Bergamo, Italy},
  month     = aug,
  pages     = {805--816},
  publisher = {Association for Computing Machinery},
  series    = {{ESEC}/{FSE} 2015},
  abstract  = {Software processes comprise many steps; coding is followed by building, integration testing, system testing, deployment, operations, among others. Software process integration and automation have been areas of key concern in software engineering, ever since the pioneering work of Osterweil; market pressures for Agility, and open, decentralized, software development have provided additional pressures for progress in this area. But do these innovations actually help projects? Given the numerous confounding factors that can influence project performance, it can be a challenge to discern the effects of process integration and automation. Software project ecosystems such as GitHub provide a new opportunity in this regard: one can readily find large numbers of projects in various stages of process integration and automation, and gather data on various influencing factors as well as productivity and quality outcomes. In this paper we use large, historical data on process metrics and outcomes in GitHub projects to discern the effects of one specific innovation in process automation: continuous integration. Our main finding is that continuous integration improves the productivity of project teams, who can integrate more outside contributions, without an observable diminishment in code quality.},
  doi       = {10.1145/2786805.2786850},
  groups    = {Joe:6},
  isbn      = {9781450336758},
  keywords  = {GitHub, pull requests, Continuous integration},
  url       = {https://doi.org/10.1145/2786805.2786850},
  urldate   = {2020-03-04},
}

@Misc{BranchTrunk2013,
  author    = {Paul Hammant},
  title     = {What is {trunk} based development},
  booktitle = {What is truck based development},
  url = {https://paulhammant.com/2013/04/05/what-is-trunk-based-development/},
  year      = {2013},
}


@Misc{BranchGITFLOW2010,
  author    = {Vincent Driessen},
  title     = {A {successful} {git} {branching} {model} - {git} flow},
  booktitle = {A {successful} {git} {branching} {model}},
  url = {https://nvie.com/posts/a-successful-git-branching-model/},
  year      = {2013},
}


@Misc{BranchGITHUBFLOW2017,
  author    = {Github},
  title     = {Github flow introduction},
  booktitle = {Github flow introduction},
  url = {https://guides.github.com/introduction/flow/},
  year      = {2017},
}

@Misc{CI2010_MartinFowler,
  author    = {Martin Fowler},
  title     = {Continous Integration},
  booktitle = {Continuous Integration},
  url = {https://www.martinfowler.com/articles/continuousIntegration.html},
  year      = {2010},
}

@Misc{TravisYamlParserOld2017,
  author    = {travis},
  title     = {travis yaml (old repository)},
  booktitle = {https://github.com/travis-ci/travis-yaml/},
  year      = {2017},
}

@Misc{TravisYamlParserNew2020,
  author    = {travis},
  title     = {travis yaml new implementation},
  booktitle = {https://github.com/travis-ci/travis-yml/},
  year      = {2020},
}

@Misc{WreckerDocs,
  author    = {Wrecker and Oracle},
  title     = {Wrecker CI development blog},
  booktitle = {Wrecker CI development blog},
  year      = {2018},
  url       = {https://devcenter.wercker.com/development/cli/usage/developing/},
}

@Misc{WreckerOpenSourceGithubSearch,
  author    = {GitHub},
  title     = {github filename search for wrecker.yml files},
  booktitle = {github filename search for wrecker.yml files},
  year      = {2020},
  url       = {https://github.com/search?q=filename%3Awrecker.yml},
}

@Misc{Github2019ForumPost,
  author    = {mscoutermarsh Github memeber of staff},
  title     = {YAML validator for Github Actions possible expansion of variables},
  booktitle = {YAML validator for Github Actions possible expansion of variables},
  year      = {2019},
  url       = {https://github.community/t5/GitHub-Actions/YAML-validator-for-Github-Actions-possible-expansion-of/td-p/29557}
}

@Misc{GithubRepoExample,
  author    = {Joseph Ling},
  title     = {CU Worhsip Song List Creator - a repository taken over for testing},
  booktitle = {CU Worhsip Song List Creator - a repository taken over for testing},
  year      = {2019},
  url       = {https://github.com/JosephLing/cuWorshipSongListCreator}
}

@Misc{GithubReadMeExample,
  author    = {Simon Tsvilik},
  title     = {wdio-docker-service},
  booktitle = {wdio-docker-service},
  year      = {2020},
  url       = {https://github.com/stsvilik/wdio-docker-service}
}

@Misc{GithubMetaDataExample,
  author    = {webdriverio},
  title     = {webdriverio},
  booktitle = {webdriverio},
  year      = {2020},
  url       = {https://github.com/webdriverio/webdriverio}
}

@Misc{GithubOctoverseResults,
  author    = {Github},
  pages     = {Top languages},
  title     = {Octoverse - Top Languages},
  booktitle     = {Octoverse - Top Languages},
  year      = {2019},
  url       = {https://octoverse.github.com/}
}

@Manual{,
}

@InProceedings{Borges2016,
  author    = {Borges, Hudson and Hora, Andre and Valente, Marco Tulio},
  booktitle = {2016 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
  title     = {Understanding the {Factors} {That} {Impact} the {Popularity} of {GitHub} {Repositories}},
  year      = {2016},
  month     = oct,
  note      = {ISSN: null},
  pages     = {334--344},
  abstract  = {Software popularity is a valuable information to modern open source developers, who constantly want to know if their systems are attracting new users, if new releases are gaining acceptance, or if they are meeting user's expectations. In this paper, we describe a study on the popularity of software systems hosted at GitHub, which is the world's largest collection of open source software. GitHub provides an explicit way for users to manifest their satisfaction with a hosted repository: the stargazers button. In our study, we reveal the main factors that impact the number of stars of GitHub projects, including programming language and application domain. We also study the impact of new features on project popularity. Finally, we identify four main patterns of popularity growth, which are derived after clustering the time series representing the number of stars of 2,279 popular GitHub repositories. We hope our results provide valuable insights to developers and maintainers, which could help them on building and evolving systems in a competitive software market.},
  doi       = {10.1109/ICSME.2016.31},
  issn      = {null},
  keywords  = {public domain software, software reviews, source code (software), time series, GitHub Repositories, open source developers, software acceptance, software system popularity, open source software, stargazers button, GitHub projects, programming language, project popularity, time series, software market, Software, Libraries, Organizations, Documentation, HTML, Java, GitHub, Software Popularity, Open Source software, Social coding},
}


@InProceedings{sheoran_understanding_2014,
  author    = {Sheoran, Jyoti and Blincoe, Kelly and Kalliamvakou, Eirini and Damian, Daniela and Ell, Jordan},
  booktitle = {Proceedings of the 11th {Working} {Conference} on {Mining} {Software} {Repositories}},
  title     = {Understanding watchers on {GitHub}},
  doi       = {10.1145/2597073.2597114},
  isbn      = {9781450328630},
  pages     = {336--339},
  publisher = {Association for Computing Machinery},
  series    = {{MSR} 2014},
  url       = {https://doi.org/10.1145/2597073.2597114},
  urldate   = {2020-03-18},
  abstract  = {Users on GitHub can watch repositories to receive notifications about project activity. This introduces a new type of passive project membership. In this paper, we investigate the behavior of watchers and their contribution to the projects they watch. We find that a subset of project watchers begin contributing to the project and those contributors account for a significant percentage of contributors on the project. As contributors, watchers are more confident and contribute over a longer period of time in a more varied way than other contributors. This is likely attributable to the knowledge gained through project notifications.},
  address   = {New York, NY, USA},
  keywords  = {Watchers, Repositories, GitHub, Software Teams},
  month     = may,
  year      = {2014},
}

@Misc{2020Wiki,
  title     = {List of programming languages by type},
  month     = mar,
  year      = {2020},
  note      = {Page Version ID: 946745400},
  abstract  = {This is a list of notable programming languages, grouped by type.
There is no overarching classification scheme for programming languages. Thus, in many cases, a language is listed under multiple headings.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  language  = {en},
  url       = {https://en.wikipedia.org/w/index.php?title=List_of_programming_languages_by_type&oldid=946745400},
  urldate   = {2020-03-23},
}

@Misc{RustBlogCargo,
  title      = {Cargo: {Rust}'s community crate host {\textbar} {Rust} {Blog}},
  year       = {2020},
  abstract   = {Empowering everyone to build reliable and efficient software.},
  language   = {en},
  shorttitle = {Cargo},
  url        = {https://blog.rust-lang.org/2014/11/20/Cargo.html},
  urldate    = {2020-03-23},
}

@Misc{GithubOctoverseResults2016,
  title      = {{GitHub} {State} of the {Octoverse}: 2016},
  abstract   = {2016 was a big year at GitHub, thanks to you. Check out the State of the Octoverse.},
  groups     = {[Joe:]},
  journal    = {GitHub Octoverse 2016},
  shorttitle = {{GitHub} {State} of the {Octoverse}},
  url        = {http://octoverse.github.com/2016},
  urldate    = {2020-04-02},
  year = {2020}

}

@Misc{GithubReadMeIncorrectFind,
  title    = {flatlogic/awesome-bootstrap-checkbox},
  abstract = {??Font Awesome Bootstrap Checkboxes \& Radios. Pure css way to make inputs look prettier - flatlogic/awesome-bootstrap-checkbox},
  groups   = {Joe:6},
  journal  = {GitHub},
  language = {en},
  url      = {https://github.com/flatlogic/awesome-bootstrap-checkbox},
  urldate  = {2020-04-03},
  year = {2020}

}


@Misc{GhTorrent2020,
  title    = {Ghtorrent website},
  journal  = {Ghtorrent},
  language = {en},
  url      = {https://ghtorrent.org/},
  urldate  = {2020-04-06},
  year = {2020}

}



@Misc{CloudBees2020,
  title    = {CloudBees website},
  journal  = {CloudBees},
  language = {en},
  url      = {https://www.cloudbees.com/},
  urldate  = {2020-04-06},
  year = {2020}

}

@Misc{YAML_FAQ_TABS,
  title    = {YAML FAQ},
  journal  = {YAML website},
  language = {en},
  url      = {https://yaml.org/faq.html},
  urldate  = {2020-04-06},
  year = {2020}

}

@Comment{jabref-meta: databaseType:bibtex;}

@Comment{jabref-meta: grouping:
0 AllEntriesGroup:;
1 StaticGroup:Markings\;2\;1\;\;\;\;;
2 StaticGroup:Joe:6\;2\;1\;\;\;\;;
2 StaticGroup:[Joe:]\;2\;1\;\;\;\;;
1 StaticGroup:Markings\;2\;1\;\;\;\;;
2 StaticGroup:Joe:6\;2\;1\;\;\;\;;
2 StaticGroup:[Joe:]\;2\;1\;\;\;\;;
}
